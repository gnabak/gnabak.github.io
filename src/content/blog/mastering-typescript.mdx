---
title: 'Mastering TypeScript: From Basics to Advanced'
description: 'A comprehensive guide to TypeScript covering essential concepts, best practices, and advanced patterns for building type-safe applications.'
pubDate: 2024-01-20
author: 'Gustavo'
image: '/images/blog/typescript.svg'
imageAlt: 'TypeScript logo'
tags: ['typescript', 'javascript', 'programming', 'guide']
category: 'guide'
featured: true
draft: false
---

# Mastering TypeScript

TypeScript has become the de facto standard for building large-scale JavaScript applications. In this guide, we'll explore everything from basics to advanced patterns.

## What is TypeScript?

TypeScript is a **superset of JavaScript** that adds static types. It compiles down to plain JavaScript, but gives you powerful tooling and error detection during development.

```typescript
// JavaScript (no type safety)
function greet(name) {
	return `Hello, ${name}!`;
}

// TypeScript (type-safe)
function greet(name: string): string {
	return `Hello, ${name}!`;
}
```

## Core Concepts

### 1. Basic Types

TypeScript provides several built-in types:

```typescript
// Primitives
let name: string = 'Gustavo';
let age: number = 25;
let isActive: boolean = true;

// Arrays
let numbers: number[] = [1, 2, 3];
let strings: Array<string> = ['a', 'b', 'c'];

// Tuples
let coordinates: [number, number] = [10, 20];

// Enums
enum Color {
	Red,
	Green,
	Blue,
}
let favorite: Color = Color.Blue;
```

### 2. Interfaces and Types

Define complex structures:

```typescript
// Interface
interface User {
	id: number;
	name: string;
	email: string;
	role?: 'admin' | 'user'; // Optional property
}

// Type alias
type Post = {
	title: string;
	content: string;
	tags: string[];
	publishedAt: Date;
};

// Using them
const user: User = {
	id: 1,
	name: 'Gustavo',
	email: 'gustavo@example.com',
};
```

### 3. Generics

Create reusable, type-safe components:

```typescript
// Generic function
function identity<T>(value: T): T {
	return value;
}

// Generic interface
interface ApiResponse<T> {
	data: T;
	status: number;
	message: string;
}

// Usage
const userResponse: ApiResponse<User> = {
	data: user,
	status: 200,
	message: 'Success',
};
```

## Advanced Patterns

### Utility Types

TypeScript provides powerful utility types:

```typescript
// Partial - makes all properties optional
type PartialUser = Partial<User>;

// Pick - select specific properties
type UserPreview = Pick<User, 'id' | 'name'>;

// Omit - exclude specific properties
type UserWithoutEmail = Omit<User, 'email'>;

// Required - makes all properties required
type RequiredUser = Required<User>;

// Record - create object type with specific keys
type UserRoles = Record<string, User>;
```

### Mapped Types

Create new types by transforming existing ones:

```typescript
type Readonly<T> = {
	readonly [P in keyof T]: T[P];
};

type Nullable<T> = {
	[P in keyof T]: T[P] | null;
};
```

### Conditional Types

Add logic to your types:

```typescript
type IsString<T> = T extends string ? true : false;

type EmailOrPhone<T> = T extends { email: string }
	? 'email'
	: T extends { phone: string }
		? 'phone'
		: 'none';
```

## Best Practices

### 1. Use Strict Mode

Always enable strict mode in `tsconfig.json`:

```json
{
	"compilerOptions": {
		"strict": true,
		"noImplicitAny": true,
		"strictNullChecks": true
	}
}
```

### 2. Avoid `any`

The `any` type defeats the purpose of TypeScript:

```typescript
// ❌ Bad
function process(data: any) {
	return data;
}

// ✅ Good
function process<T>(data: T): T {
	return data;
}
```

### 3. Use Type Guards

Narrow types safely:

```typescript
function isUser(obj: any): obj is User {
	return (
		typeof obj === 'object' &&
		'id' in obj &&
		'name' in obj &&
		'email' in obj
	);
}

if (isUser(data)) {
	// TypeScript knows data is User here
	console.log(data.email);
}
```

### 4. Leverage Union and Intersection Types

```typescript
// Union - can be one of several types
type Status = 'pending' | 'approved' | 'rejected';

// Intersection - must satisfy all types
type Employee = User & {
	department: string;
	salary: number;
};
```

## Real-World Example

Here's a complete example of a type-safe API client:

```typescript
interface ApiConfig {
	baseUrl: string;
	headers?: Record<string, string>;
}

class ApiClient {
	constructor(private config: ApiConfig) {}

	async get<T>(endpoint: string): Promise<ApiResponse<T>> {
		const response = await fetch(`${this.config.baseUrl}${endpoint}`, {
			headers: this.config.headers,
		});
		return response.json();
	}

	async post<T, D>(endpoint: string, data: D): Promise<ApiResponse<T>> {
		const response = await fetch(`${this.config.baseUrl}${endpoint}`, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				...this.config.headers,
			},
			body: JSON.stringify(data),
		});
		return response.json();
	}
}

// Usage
const api = new ApiClient({ baseUrl: 'https://api.example.com' });
const users = await api.get<User[]>('/users');
```

## Conclusion

TypeScript transforms JavaScript development by adding type safety, better tooling, and improved maintainability. The initial learning curve is worth it for:

- **Catching errors** before runtime
- **Better IDE support** with autocomplete and refactoring
- **Self-documenting code** through types
- **Confidence** when refactoring large codebases

Start small, gradually adopt TypeScript in your projects, and you'll never want to go back to plain JavaScript!

## Resources

- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
- [Type Challenges](https://github.com/type-challenges/type-challenges)
