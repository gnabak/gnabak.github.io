---
title: 'ShopSphere - E-commerce Platform'
description: 'A scalable e-commerce platform with advanced product filtering, cart management, and Stripe payment integration.'
techStack: ['Next.js', 'TypeScript', 'Prisma', 'PostgreSQL', 'Stripe', 'TailwindCSS', 'Vercel']
demoUrl: 'https://shopsphere-demo.example.com'
githubUrl: 'https://github.com/yourusername/shopsphere'
featured: true
completedDate: 2023-12-10
order: 2
---

# ShopSphere - E-commerce Platform

A modern, performant e-commerce platform built with Next.js and Stripe, offering a seamless shopping experience with advanced filtering and secure payments.

## ğŸ›ï¸ Project Overview

ShopSphere is a full-featured e-commerce platform designed for scalability and performance. It provides everything needed to run an online store: product management, shopping cart, checkout flow, and order tracking.

## âœ¨ Key Features

### Product Catalog
- **Advanced filtering** by category, price, brand, and custom attributes
- **Search functionality** with instant results
- **Product variants** (size, color, etc.)
- **Image galleries** with zoom and lightbox
- **Related products** suggestions
- **Inventory management** with stock tracking

### Shopping Experience
- **Persistent shopping cart** across sessions
- **Wishlist** for saving favorites
- **Guest checkout** without account required
- **Multiple payment methods** via Stripe
- **Coupon codes** and discounts
- **Shipping calculator** based on location

### User Features
- **User authentication** with NextAuth
- **Order history** and tracking
- **Saved addresses** for quick checkout
- **Product reviews** and ratings
- **Email notifications** for order updates

### Admin Dashboard
- **Product management** (CRUD operations)
- **Order management** and fulfillment
- **Customer management**
- **Analytics dashboard** with sales metrics
- **Inventory tracking**
- **Discount code management**

## ğŸ› ï¸ Technical Implementation

### Product Filtering System

Built an efficient filtering system with URL state:

```typescript
// Filter component with URL synchronization
interface FilterState {
	category?: string;
	priceRange?: [number, number];
	brands?: string[];
	sortBy?: 'price-asc' | 'price-desc' | 'newest';
}

function ProductFilters() {
	const router = useRouter();
	const searchParams = useSearchParams();

	const updateFilters = (newFilters: Partial<FilterState>) => {
		const params = new URLSearchParams(searchParams);

		Object.entries(newFilters).forEach(([key, value]) => {
			if (value) {
				params.set(key, JSON.stringify(value));
			} else {
				params.delete(key);
			}
		});

		router.push(`/products?${params.toString()}`);
	};

	return (
		<div className="space-y-6">
			<PriceRangeFilter onChange={(range) => updateFilters({ priceRange: range })} />
			<CategoryFilter onChange={(cat) => updateFilters({ category: cat })} />
			<BrandFilter onChange={(brands) => updateFilters({ brands })} />
		</div>
	);
}
```

### Shopping Cart Management

Implemented with React Context and local storage:

```typescript
interface CartItem {
	productId: string;
	variantId?: string;
	quantity: number;
	price: number;
}

interface CartContextType {
	items: CartItem[];
	addItem: (item: CartItem) => void;
	removeItem: (productId: string) => void;
	updateQuantity: (productId: string, quantity: number) => void;
	total: number;
	clearCart: () => void;
}

export function CartProvider({ children }: { children: React.ReactNode }) {
	const [items, setItems] = useState<CartItem[]>([]);

	// Persist to localStorage
	useEffect(() => {
		const saved = localStorage.getItem('cart');
		if (saved) {
			setItems(JSON.parse(saved));
		}
	}, []);

	useEffect(() => {
		localStorage.setItem('cart', JSON.stringify(items));
	}, [items]);

	const addItem = (item: CartItem) => {
		setItems((prev) => {
			const existing = prev.find((i) => i.productId === item.productId);
			if (existing) {
				return prev.map((i) =>
					i.productId === item.productId
						? { ...i, quantity: i.quantity + item.quantity }
						: i
				);
			}
			return [...prev, item];
		});
	};

	const total = items.reduce((sum, item) => sum + item.price * item.quantity, 0);

	return (
		<CartContext.Provider value={{ items, addItem, removeItem, updateQuantity, total, clearCart }}>
			{children}
		</CartContext.Provider>
	);
}
```

### Stripe Payment Integration

Secure checkout with Stripe:

```typescript
// API route for creating payment intent
export async function POST(req: Request) {
	const { items } = await req.json();

	// Calculate order amount
	const amount = await calculateOrderAmount(items);

	// Create payment intent
	const paymentIntent = await stripe.paymentIntents.create({
		amount,
		currency: 'usd',
		automatic_payment_methods: {
			enabled: true,
		},
		metadata: {
			orderItems: JSON.stringify(items),
		},
	});

	return Response.json({
		clientSecret: paymentIntent.client_secret,
	});
}

// Checkout component
function CheckoutForm() {
	const stripe = useStripe();
	const elements = useElements();
	const { items, total, clearCart } = useCart();

	const handleSubmit = async (e: React.FormEvent) => {
		e.preventDefault();

		if (!stripe || !elements) return;

		const { error, paymentIntent } = await stripe.confirmPayment({
			elements,
			redirect: 'if_required',
		});

		if (error) {
			toast.error(error.message);
		} else if (paymentIntent.status === 'succeeded') {
			// Create order in database
			await createOrder({
				items,
				total,
				paymentIntentId: paymentIntent.id,
			});

			clearCart();
			router.push('/order-confirmation');
		}
	};

	return (
		<form onSubmit={handleSubmit}>
			<PaymentElement />
			<button type="submit" disabled={!stripe}>
				Pay ${total.toFixed(2)}
			</button>
		</form>
	);
}
```

### Database Schema

```prisma
model Product {
  id          String   @id @default(cuid())
  name        String
  description String
  price       Decimal  @db.Decimal(10, 2)
  images      String[]
  category    Category @relation(fields: [categoryId], references: [id])
  categoryId  String

  variants    ProductVariant[]
  reviews     Review[]
  orderItems  OrderItem[]

  stock       Int      @default(0)
  featured    Boolean  @default(false)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Order {
  id              String      @id @default(cuid())
  orderNumber     String      @unique
  status          OrderStatus @default(PENDING)
  total           Decimal     @db.Decimal(10, 2)

  user            User?       @relation(fields: [userId], references: [id])
  userId          String?

  items           OrderItem[]

  shippingAddress Json
  billingAddress  Json

  paymentIntentId String      @unique

  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
}

model OrderItem {
  id        String  @id @default(cuid())
  quantity  Int
  price     Decimal @db.Decimal(10, 2)

  product   Product @relation(fields: [productId], references: [id])
  productId String

  order     Order   @relation(fields: [orderId], references: [id])
  orderId   String
}
```

## ğŸ¨ UI/UX Features

### Product Page
- High-quality image gallery with magnification
- Detailed product specifications
- Size/variant selector with stock availability
- Customer reviews with photos
- Recommended products carousel
- Breadcrumb navigation

### Shopping Cart
- Slide-out cart drawer for quick view
- Real-time price calculations
- Quantity adjustment controls
- Continue shopping vs. checkout CTAs
- Applied coupons display
- Estimated shipping costs

### Checkout Flow
- Multi-step checkout (shipping â†’ payment â†’ review)
- Address autocomplete
- Save address for future orders
- Multiple payment methods
- Order summary sidebar
- Progress indicator

## ğŸ“ˆ Performance Optimizations

### Image Optimization
- **Next.js Image** component with automatic optimization
- **WebP/AVIF** format conversion
- **Lazy loading** for off-screen images
- **Blur placeholder** for better perceived performance
- **Responsive images** for different screen sizes

### Code Optimization
- **Route-based code splitting** with dynamic imports
- **React Server Components** for zero-JS where possible
- **API route caching** with Redis
- **Database query optimization** with proper indexing
- **Edge functions** for global performance

### SEO Optimization
- **Dynamic metadata** for product pages
- **Structured data** (Product, Breadcrumb schemas)
- **Sitemap generation** for all products
- **Canonical URLs** to prevent duplicates
- **Open Graph** images for social sharing

## ğŸš€ Deployment Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Vercel    â”‚  â† Next.js App (SSR + Static)
â”‚   (Edge)    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚             â”‚
       â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚PostgreSQLâ”‚   â”‚  Stripe  â”‚
â”‚(Supabase)â”‚   â”‚    API   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Redis   â”‚  â† Caching
â”‚ (Upstash)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Key Metrics

- **Page Load Time:** < 1.5s (Lighthouse)
- **Core Web Vitals:** All green
- **Conversion Rate:** 3.2%
- **Cart Abandonment:** 65% (industry average: 70%)
- **Mobile Traffic:** 60%

## ğŸ“ Challenges & Solutions

### Challenge: Product Filtering Performance
**Problem:** Filtering thousands of products was slow

**Solution:**
- Implemented database indexes on filter columns
- Added Redis caching for popular filter combinations
- Used URL params for shareable filter states
- Implemented virtual scrolling for results

### Challenge: Cart Persistence
**Problem:** Users lost cart items when switching devices

**Solution:**
- Implemented both localStorage (anonymous) and database (logged-in)
- Merged carts on login
- Added cart expiration for abandoned carts

### Challenge: Payment Security
**Problem:** Ensuring PCI compliance

**Solution:**
- Used Stripe's hosted payment elements (no card data touches server)
- Implemented webhook verification
- Added fraud detection with Stripe Radar
- Used environment-specific API keys

## ğŸ”® Future Enhancements

- [ ] Add product recommendation engine with ML
- [ ] Implement subscription products
- [ ] Add multi-currency support
- [ ] Build mobile app with React Native
- [ ] Add live chat support
- [ ] Implement advanced analytics dashboard
- [ ] Add multi-vendor marketplace features
- [ ] Integrate with shipping APIs for real-time rates

## ğŸ”— Links

- **Live Demo:** [shopsphere-demo.example.com](https://shopsphere-demo.example.com)
- **GitHub:** [github.com/yourusername/shopsphere](https://github.com/yourusername/shopsphere)
- **Case Study:** [Full case study](https://example.com/case-study)

## ğŸ’» Tech Stack

**Frontend:**
- Next.js 14 (App Router)
- TypeScript
- Tailwind CSS
- Radix UI primitives
- React Hook Form
- Zod validation

**Backend:**
- Next.js API Routes
- Prisma ORM
- PostgreSQL (Supabase)
- Redis (Upstash)
- NextAuth.js

**Payment:**
- Stripe Checkout
- Stripe Webhooks
- Stripe Radar (fraud detection)

**Infrastructure:**
- Vercel (hosting)
- GitHub Actions (CI/CD)
- Sentry (error tracking)
- Vercel Analytics

---

*This project showcases my ability to build production-ready e-commerce applications with complex business logic, payment processing, and optimized performance.*
